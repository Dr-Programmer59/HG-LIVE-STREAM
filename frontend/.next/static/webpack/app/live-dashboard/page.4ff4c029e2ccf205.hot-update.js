"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/live-dashboard/page",{

/***/ "(app-pages-browser)/./src/mediasoup/webrtc_mediasoup_host.js":
/*!************************************************!*\
  !*** ./src/mediasoup/webrtc_mediasoup_host.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ webrtcMediaSoup_client; }\n/* harmony export */ });\n/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mediasoup-client */ \"(app-pages-browser)/./node_modules/mediasoup-client/lib/index.js\");\n/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mediasoup_client__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(app-pages-browser)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction createSilentAudioTrack() {\n    const audioContext = new AudioContext();\n    const oscillator = audioContext.createOscillator();\n    const destination = audioContext.createMediaStreamDestination();\n    oscillator.frequency.value = 0; // Set frequency to 0 to generate silence\n    oscillator.connect(destination);\n    oscillator.start();\n    return destination.stream.getAudioTracks()[0];\n}\nclass webrtcMediaSoup_client {\n    joinRoom() {\n        console.log(this.mystream);\n        this.socket.emit(\"joinRoom\", {\n            roomName: this.roomName\n        }, (data)=>{\n            console.log(\"Router RTP Capabilities... \".concat(data.rtpCapabilities));\n            // we assign to local variable and will be used when\n            // loading the client Device (see createDevice above)\n            this.rtpCapabilities = data.rtpCapabilities;\n            // once we have rtpCapabilities from the Router, create Device\n            this.createDevice();\n        });\n    }\n    streamSuccess(stream) {\n        console.log(\"succesffuly get the media\");\n        if (stream.getAudioTracks().length === 0) {\n            // Create and add a silent audio track if none exists\n            const silentAudioTrack = createSilentAudioTrack();\n            stream.addTrack(silentAudioTrack);\n        }\n        this.mystream = stream;\n        this.mystreamCopy = stream;\n        this.audioParams = {\n            track: stream.getAudioTracks()[0],\n            ...this.audioParams\n        };\n        this.videoParams = {\n            track: stream.getVideoTracks()[0],\n            ...this.videoParams\n        };\n        this.joinRoom();\n    }\n    getLocalStream() {\n        console.log(\"succesffuly get the media\");\n        if (this.isscreenShared) {\n            navigator.mediaDevices.getDisplayMedia({\n                audio: true,\n                video: true\n            }).then((stream)=>{\n                this.streamSuccess(stream);\n            }).catch((error)=>{\n                console.log(error.message);\n            });\n        } else {\n            navigator.mediaDevices.getUserMedia({\n                audio: true,\n                video: true\n            }).then((stream)=>{\n                this.streamSuccess(stream);\n            }).catch((error)=>{\n                console.log(error.message);\n            });\n        }\n    }\n    // A device is an endpoint connecting to a Router on the\n    // server side to send/recive media\n    async createDevice() {\n        try {\n            this.device = new mediasoup_client__WEBPACK_IMPORTED_MODULE_0__.Device();\n            // https://mediasoup.org/documentation/v3/mediasoup-client/api/#device-load\n            // Loads the device with RTP capabilities of the Router (server side)\n            await this.device.load({\n                // see getRtpCapabilities() below\n                routerRtpCapabilities: this.rtpCapabilities\n            });\n            console.log(\"Device RTP Capabilities\", this.device.rtpCapabilities);\n            // once the device loads, create transport\n            this.createSendTransport();\n        } catch (error) {\n            console.log(error);\n            if (error.name === \"UnsupportedError\") console.warn(\"browser not supported\");\n        }\n        console.log(\"this is device created\", this.device);\n    }\n    createSendTransport() {\n        // see server's socket.on('createWebRtcTransport', sender?, ...)\n        // this is a call from Producer, so sender = true\n        this.socket.emit(\"createWebRtcTransport\", {\n            consumer: false\n        }, (param)=>{\n            let { params } = param;\n            // The server sends back params needed \n            // to create Send Transport on the client side\n            if (params.error) {\n                console.log(params.error);\n                return;\n            }\n            console.log(params);\n            // creates a new WebRTC Transport to send media\n            // based on the server's producer transport params\n            // https://mediasoup.org/documentation/v3/mediasoup-client/api/#TransportOptions\n            this.producerTransport = this.device.createSendTransport({\n                ...params,\n                iceServers: [\n                    {\n                        \"urls\": \"stun:stun1.l.google.com:19302\"\n                    }\n                ]\n            });\n            // https://mediasoup.org/documentation/v3/communication-between-client-and-server/#producing-media\n            // this event is raised when a first call to transport.produce() is made\n            // see connectSendTransport() below\n            this.producerTransport.on(\"connect\", async (param, callback, errback)=>{\n                let { dtlsParameters } = param;\n                try {\n                    // Signal local DTLS parameters to the server side transport\n                    // see server's socket.on('transport-connect', ...)\n                    await this.socket.emit(\"transport-connect\", {\n                        dtlsParameters\n                    });\n                    // Tell the transport that parameters were transmitted.\n                    callback();\n                } catch (error) {\n                    errback(error);\n                }\n            });\n            this.producerTransport.on(\"produce\", async (parameters, callback, errback)=>{\n                console.log(parameters);\n                try {\n                    // tell the server to create a Producer\n                    // with the following parameters and produce\n                    // and expect back a server side producer id\n                    // see server's socket.on('transport-produce', ...)\n                    await this.socket.emit(\"transport-produce\", {\n                        kind: parameters.kind,\n                        rtpParameters: parameters.rtpParameters,\n                        appData: parameters.appData,\n                        admin: this.isAdmin,\n                        viewer: false\n                    }, (param)=>{\n                        let { id, producersExist } = param;\n                        // Tell the transport that parameters were transmitted and provide it with the\n                        // server side producer's id.\n                        callback({\n                            id\n                        });\n                        // if producers exist, then join room\n                        if (producersExist) this.getProducers();\n                    });\n                } catch (error) {\n                    errback(error);\n                }\n            });\n            this.connectSendTransport();\n        });\n    }\n    handleScreenShareOff() {\n        navigator.mediaDevices.getUserMedia({\n            audio: true,\n            video: {\n                width: {\n                    min: 640,\n                    max: 1920\n                },\n                height: {\n                    min: 400,\n                    max: 1080\n                }\n            }\n        }).then((stream)=>{\n            this.videoParams = {\n                track: stream.getVideoTracks()[0],\n                ...this.videoParams\n            };\n            const videoTracks = this.mystream.getVideoTracks();\n            // Remove each video track\n            videoTracks.forEach((track)=>{\n                this.mystream.removeTrack(track);\n                track.stop(); // Stop the removed track to release resources\n            });\n            this.mystream.addTrack(stream.getVideoTracks()[0]);\n            this.videoProducer.replaceTrack({\n                track: stream.getVideoTracks()[0]\n            });\n        }).catch((error)=>{\n            console.log(error.message);\n        });\n    }\n    getlocalDisplayScreen() {\n        navigator.mediaDevices.getDisplayMedia({\n            video: true\n        }).then((stream)=>{\n            const screenTrack = stream.getTracks()[0];\n            this.videoProducer.replaceTrack({\n                track: screenTrack\n            });\n            screenTrack.onended = function() {\n                this.videoProducer.replaceTrack(userStream.current.getTracks()[1]);\n            };\n            const videoTracks = this.mystream.getVideoTracks();\n            // Remove each video track\n            videoTracks.forEach((track)=>{\n                this.mystream.removeTrack(track);\n                track.stop(); // Stop the removed track to release resources\n            });\n            this.mystream.addTrack(screenTrack);\n        }).catch((error)=>{\n            console.log(error.message);\n        });\n    }\n    async connectSendTransport() {\n        // we now call produce() to instruct the producer transport\n        // to send media to the Router\n        // https://mediasoup.org/documentation/v3/mediasoup-client/api/#transport-produce\n        // this action will trigger the 'connect' and 'produce' events above\n        if (this.mystream.getAudioTracks() != []) this.audioProducer = await this.producerTransport.produce(this.audioParams);\n        this.videoProducer = await this.producerTransport.produce(this.videoParams);\n        this.audioProducer.on(\"trackended\", ()=>{\n            console.log(\"audio track ended\");\n            this.audioDisconnect = true;\n        // close audio track\n        });\n        this.audioProducer.on(\"transportclose\", ()=>{\n            console.log(\"audio transport ended\");\n            this.audioDisconnect = true;\n        // close audio track\n        });\n        this.videoProducer.on(\"trackended\", ()=>{\n            console.log(\"video track ended\");\n            this.socket.disconnect();\n            this.videoDisconnect = true;\n        // close video track\n        });\n        this.videoProducer.on(\"transportclose\", ()=>{\n            console.log(\"video transport ended\");\n            this.videoDisconnect = true;\n        // close video track\n        });\n    }\n    async signalNewConsumerTransport(remoteProducerId, viewer) {\n        //check if we are already consuming the remoteProducerId\n        console.log(\"this is viewer in start \", viewer);\n        if (this.consumingTransports.includes(remoteProducerId)) return;\n        this.consumingTransports.push(remoteProducerId);\n        await this.socket.emit(\"createWebRtcTransport\", {\n            consumer: true\n        }, (param)=>{\n            let { params } = param;\n            // The server sends back params needed \n            // to create Send Transport on the client side\n            if (params.error) {\n                console.log(params.error);\n                return;\n            }\n            console.log(\"PARAMS... \".concat(params));\n            let consumerTransport;\n            try {\n                console.log(\"checking \", this.mystream);\n                consumerTransport = this.device.createRecvTransport(params);\n            } catch (error) {\n                // exceptions: \n                // {InvalidStateError} if not loaded\n                // {TypeError} if wrong arguments.\n                console.log(error);\n                return;\n            }\n            consumerTransport.on(\"connect\", async (param, callback, errback)=>{\n                let { dtlsParameters } = param;\n                try {\n                    // Signal local DTLS parameters to the server side transport\n                    // see server's socket.on('transport-recv-connect', ...)\n                    await this.socket.emit(\"transport-recv-connect\", {\n                        dtlsParameters,\n                        serverConsumerTransportId: params.id\n                    });\n                    // Tell the transport that parameters were transmitted.\n                    callback();\n                } catch (error) {\n                    // Tell the transport that something was wrong\n                    errback(error);\n                }\n            });\n            this.connectRecvTransport(consumerTransport, remoteProducerId, params.id, viewer);\n        });\n    }\n    async signalNewConsumerTransportHost(hostdata, socketId) {\n        //check if we are already consuming the remoteProducerId\n        if (this.consumingTransports.includes(hostdata[\"producerId\"])) return;\n        this.consumingTransports.push(hostdata[\"producerId\"]);\n        await this.socket.emit(\"createWebRtcTransport\", {\n            consumer: true\n        }, (param)=>{\n            let { params } = param;\n            // The server sends back params needed \n            // to create Send Transport on the client side\n            if (params.error) {\n                console.log(params.error);\n                return;\n            }\n            console.log(\"PARAMS... \".concat(params));\n            let consumerTransport;\n            try {\n                console.log(\"checking \", this.mystream);\n                consumerTransport = this.device.createRecvTransport(params);\n            } catch (error) {\n                // exceptions: \n                // {InvalidStateError} if not loaded\n                // {TypeError} if wrong arguments.\n                console.log(error);\n                return;\n            }\n            consumerTransport.on(\"connect\", async (param, callback, errback)=>{\n                let { dtlsParameters } = param;\n                try {\n                    // Signal local DTLS parameters to the server side transport\n                    // see server's socket.on('transport-recv-connect', ...)\n                    await this.socket.emit(\"transport-recv-connect\", {\n                        dtlsParameters,\n                        serverConsumerTransportId: params.id\n                    });\n                    // Tell the transport that parameters were transmitted.\n                    callback();\n                } catch (error) {\n                    // Tell the transport that something was wrong\n                    errback(error);\n                }\n            });\n            this.connectRecvTransportHost(consumerTransport, hostdata, socketId, params.id);\n        });\n    }\n    // server informs the client of a new producer just joined\n    getProducers() {\n        this.socket.emit(\"getProducers\", (producerIds)=>{\n            console.log(producerIds);\n            // for each of the producer create a consumer\n            // producerIds.forEach(id => signalNewConsumerTransport(id))\n            producerIds.forEach(this.signalNewConsumerTransportHost);\n        });\n    }\n    async connectRecvTransportHost(consumerTransport, hostdata, socketId, serverConsumerTransportId) {\n        // for consumer, we need to tell the server first\n        // to create a consumer based on the rtpCapabilities and consume\n        // if the router can consume, it will send back a set of params as below\n        await this.socket.emit(\"consume\", {\n            rtpCapabilities: this.device.rtpCapabilities,\n            remoteProducerId: hostdata[\"producerId\"],\n            serverConsumerTransportId\n        }, async (param)=>{\n            let { params } = param;\n            if (params.error) {\n                console.log(\"Cannot Consume\");\n                return;\n            }\n            console.log(\"Consumer Params \".concat(params));\n            // then consume with the local consumer transport\n            // which creates a consumer\n            const consumer = await consumerTransport.consume({\n                id: params.id,\n                producerId: params.producerId,\n                kind: params.kind,\n                rtpParameters: params.rtpParameters\n            });\n            this.consumerTransports = [\n                ...this.consumerTransports,\n                {\n                    consumerTransport,\n                    serverConsumerTransportId: params.id,\n                    producerId: hostdata[\"producerId\"],\n                    consumer\n                }\n            ];\n            // create a new div element for the new consumer media\n            // destructure and retrieve the video track from the producer\n            const { track } = consumer;\n            console.log(track, \"track receive\");\n            console.log(\"track \", track, \" producer id \", hostdata[\"producerId\"]);\n            let trackreq = new MediaStream([\n                track\n            ]);\n            if (!this.mainTracks[socketId]) {\n                this.mainTracks[socketId] = [];\n            }\n            this.mainTracks[socketId].push({\n                producerId: hostdata[\"producerId\"],\n                media: trackreq,\n                producerKind: hostdata[\"producerKind\"]\n            });\n            // document.getElementById(remoteProducerId).srcObject = new MediaStream([track])\n            console.log(\"this is track\", this.mainTracks);\n            // the server consumer started with media paused\n            // so we need to inform the server to resume\n            this.socket.emit(\"consumer-resume\", {\n                serverConsumerId: params.serverConsumerId\n            });\n        });\n    }\n    async connectRecvTransport(consumerTransport, remoteProducerId, serverConsumerTransportId, viewer) {\n        // for consumer, we need to tell the server first\n        // to create a consumer based on the rtpCapabilities and consume\n        // if the router can consume, it will send back a set of params as below\n        await this.socket.emit(\"consume\", {\n            rtpCapabilities: this.device.rtpCapabilities,\n            remoteProducerId,\n            serverConsumerTransportId\n        }, async (param)=>{\n            let { params } = param;\n            if (params.error) {\n                console.log(\"Cannot Consume\");\n                return;\n            }\n            console.log(\"Consumer Params \".concat(params));\n            // then consume with the local consumer transport\n            // which creates a consumer\n            const consumer = await consumerTransport.consume({\n                id: params.id,\n                producerId: params.producerId,\n                kind: params.kind,\n                rtpParameters: params.rtpParameters\n            });\n            this.consumerTransports = [\n                ...this.consumerTransports,\n                {\n                    consumerTransport,\n                    serverConsumerTransportId: params.id,\n                    producerId: remoteProducerId,\n                    consumer\n                }\n            ];\n            // create a new div element for the new consumer media\n            // destructure and retrieve the video track from the producer\n            const { track } = consumer;\n            console.log(\"track \", track, \" producer id \", remoteProducerId);\n            let trackreq = new MediaStream([\n                track\n            ]);\n            if (viewer) {\n                this.callers.push(trackreq);\n            } else {\n                this.mainTracks.push(trackreq);\n            }\n            // document.getElementById(remoteProducerId).srcObject = new MediaStream([track])\n            console.log(\"this is track\", track);\n            // the server consumer started with media paused\n            // so we need to inform the server to resume\n            this.socket.emit(\"consumer-resume\", {\n                serverConsumerId: params.serverConsumerId\n            });\n        });\n    }\n    constructor(isAdmin, socket, isscreenShared){\n        this.socket = socket;\n        this.isscreenShared = isscreenShared;\n        this.device;\n        this.roomName;\n        this.rtpCapabilities;\n        this.producerTransport;\n        this.consumerTransports = [];\n        this.audioProducer;\n        this.videoProducer;\n        this.consumer;\n        this.mainTracks = {};\n        this.callers = [];\n        this.isProducer = false;\n        this.mystream = null;\n        this.audioDisconnect = false;\n        this.videoDisconnect = false;\n        this.mystreamCopy = null;\n        this.isAdmin = isAdmin;\n        this.params = {\n            // mediasoup params\n            encodings: [\n                {\n                    rid: \"r0\",\n                    maxBitrate: 100000,\n                    scalabilityMode: \"S1T3\"\n                },\n                {\n                    rid: \"r1\",\n                    maxBitrate: 300000,\n                    scalabilityMode: \"S1T3\"\n                },\n                {\n                    rid: \"r2\",\n                    maxBitrate: 900000,\n                    scalabilityMode: \"S1T3\"\n                }\n            ],\n            // https://mediasoup.org/documentation/v3/mediasoup-client/api/#ProducerCodecOptions\n            codecOptions: {\n                videoGoogleStartBitrate: 1000\n            }\n        };\n        this.audioParams;\n        this.consumingTransports = [];\n        this.videoParams = {\n            // mediasoup params\n            encodings: [\n                {\n                    rid: \"r0\",\n                    maxBitrate: 100000,\n                    scalabilityMode: \"S1T3\"\n                },\n                {\n                    rid: \"r1\",\n                    maxBitrate: 300000,\n                    scalabilityMode: \"S1T3\"\n                },\n                {\n                    rid: \"r2\",\n                    maxBitrate: 900000,\n                    scalabilityMode: \"S1T3\"\n                }\n            ],\n            // https://mediasoup.org/documentation/v3/mediasoup-client/api/#ProducerCodecOptions\n            codecOptions: {\n                videoGoogleStartBitrate: 1000\n            }\n        };\n        this.signalNewConsumerTransport = this.signalNewConsumerTransport.bind(this);\n        this.connectRecvTransport = this.connectRecvTransport.bind(this);\n        this.signalNewConsumerTransportHost = this.signalNewConsumerTransportHost.bind(this);\n    // this.signalNewConsumerTransport=this.signalNewConsumerTransport.bind(this)\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9tZWRpYXNvdXAvd2VicnRjX21lZGlhc291cF9ob3N0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTREO0FBQ25CO0FBQ3FCO0FBQzlELFNBQVNHO0lBQ1AsTUFBTUMsZUFBZSxJQUFJQztJQUN6QixNQUFNQyxhQUFhRixhQUFhRyxnQkFBZ0I7SUFDaEQsTUFBTUMsY0FBY0osYUFBYUssNEJBQTRCO0lBRTdESCxXQUFXSSxTQUFTLENBQUNDLEtBQUssR0FBRyxHQUFHLHlDQUF5QztJQUN6RUwsV0FBV00sT0FBTyxDQUFDSjtJQUNuQkYsV0FBV08sS0FBSztJQUVoQixPQUFPTCxZQUFZTSxNQUFNLENBQUNDLGNBQWMsRUFBRSxDQUFDLEVBQUU7QUFDL0M7QUFDZSxNQUFNQztJQWlGakJDLFdBQVk7UUFFVkMsUUFBUUMsR0FBRyxDQUFDLElBQUksQ0FBQ0MsUUFBUTtRQUN6QixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLFlBQVk7WUFBRUMsVUFBUyxJQUFJLENBQUNBLFFBQVE7UUFBQyxHQUFHLENBQUNDO1lBQ3hETixRQUFRQyxHQUFHLENBQUMsOEJBQW1ELE9BQXJCSyxLQUFLQyxlQUFlO1lBQzlELG9EQUFvRDtZQUNwRCxxREFBcUQ7WUFDckQsSUFBSSxDQUFDQSxlQUFlLEdBQUdELEtBQUtDLGVBQWU7WUFFM0MsOERBQThEO1lBQzlELElBQUksQ0FBQ0MsWUFBWTtRQUNuQjtJQUNGO0lBR0FDLGNBQWNiLE1BQU0sRUFBQztRQUNuQkksUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSUwsT0FBT0MsY0FBYyxHQUFHYSxNQUFNLEtBQUssR0FBRztZQUN4QyxxREFBcUQ7WUFDckQsTUFBTUMsbUJBQW1CMUI7WUFDekJXLE9BQU9nQixRQUFRLENBQUNEO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDVCxRQUFRLEdBQUNOO1FBQ2QsSUFBSSxDQUFDaUIsWUFBWSxHQUFDakI7UUFDbEIsSUFBSSxDQUFDa0IsV0FBVyxH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O2dCQUNUO29CQUNFQyxLQUFLO29CQUNMQyxZQUFZO29CQUNaQyxpQkFBaUI7Z0JBQ25CO2dCQUNBO29CQUNFRixLQUFLO29CQUNMQyxZQUFZO29CQUNaQyxpQkFBaUI7Z0JBQ25CO2dCQUNBO29CQUNFRixLQUFLO29CQUNMQyxZQUFZO29CQUNaQyxpQkFBaUI7Z0JBQ25CO2FBQ0Q7WUFDRCxvRkFBb0Y7WUFDcEZDLGNBQWM7Z0JBQ1pDLHlCQUF5QjtZQUMzQjtRQUNGO1FBQ0EsSUFBSSxDQUFDL0IsMEJBQTBCLEdBQUMsSUFBSSxDQUFDQSwwQkFBMEIsQ0FBQ2dDLElBQUksQ0FBQyxJQUFJO1FBQ3pFLElBQUksQ0FBQ3hCLG9CQUFvQixHQUFDLElBQUksQ0FBQ0Esb0JBQW9CLENBQUN3QixJQUFJLENBQUMsSUFBSTtRQUM3RCxJQUFJLENBQUN2Qiw4QkFBOEIsR0FBQyxJQUFJLENBQUNBLDhCQUE4QixDQUFDdUIsSUFBSSxDQUFDLElBQUk7SUFFakYsNkVBQTZFO0lBRW5GO0FBK2RKO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL21lZGlhc291cC93ZWJydGNfbWVkaWFzb3VwX2hvc3QuanM/MTY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xyXG5pbXBvcnQgeyBEZXZpY2UgfSBmcm9tIFwibWVkaWFzb3VwLWNsaWVudFwiXHJcbmltcG9ydCB7IHNldFJlcXVlc3RNZXRhIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC1tZXRhXCJcclxuZnVuY3Rpb24gY3JlYXRlU2lsZW50QXVkaW9UcmFjaygpIHtcclxuICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcbiAgY29uc3Qgb3NjaWxsYXRvciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgY29uc3QgZGVzdGluYXRpb24gPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xyXG5cclxuICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IDA7IC8vIFNldCBmcmVxdWVuY3kgdG8gMCB0byBnZW5lcmF0ZSBzaWxlbmNlXHJcbiAgb3NjaWxsYXRvci5jb25uZWN0KGRlc3RpbmF0aW9uKTtcclxuICBvc2NpbGxhdG9yLnN0YXJ0KCk7XHJcblxyXG4gIHJldHVybiBkZXN0aW5hdGlvbi5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB3ZWJydGNNZWRpYVNvdXBfY2xpZW50e1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGlzQWRtaW4sc29ja2V0LGlzc2NyZWVuU2hhcmVkKXtcclxuXHJcbiAgICAgICAgdGhpcy5zb2NrZXQ9c29ja2V0XHJcbiAgICAgICAgdGhpcy5pc3NjcmVlblNoYXJlZD1pc3NjcmVlblNoYXJlZDtcclxuICAgICAgICB0aGlzLmRldmljZVxyXG4gICAgICAgIHRoaXMucm9vbU5hbWU7XHJcbiAgICAgICAgdGhpcy5ydHBDYXBhYmlsaXRpZXNcclxuICAgICAgICB0aGlzLnByb2R1Y2VyVHJhbnNwb3J0XHJcbiAgICAgICAgdGhpcy5jb25zdW1lclRyYW5zcG9ydHMgPSBbXVxyXG4gICAgICAgIHRoaXMuYXVkaW9Qcm9kdWNlclxyXG4gICAgICAgIHRoaXMudmlkZW9Qcm9kdWNlclxyXG4gICAgICAgIHRoaXMuY29uc3VtZXJcclxuICAgICAgICB0aGlzLm1haW5UcmFja3M9e31cclxuICAgICAgICB0aGlzLmNhbGxlcnM9W11cclxuICAgICAgICB0aGlzLmlzUHJvZHVjZXIgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMubXlzdHJlYW09bnVsbFxyXG4gICAgICAgIHRoaXMuYXVkaW9EaXNjb25uZWN0PWZhbHNlXHJcbiAgICAgICAgdGhpcy52aWRlb0Rpc2Nvbm5lY3Q9ZmFsc2VcclxuICAgICAgICB0aGlzLm15c3RyZWFtQ29weT1udWxsXHJcbiAgICAgICAgdGhpcy5pc0FkbWluPWlzQWRtaW5cclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHtcclxuICAgICAgICAgICAgLy8gbWVkaWFzb3VwIHBhcmFtc1xyXG4gICAgICAgICAgICBlbmNvZGluZ3M6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByaWQ6ICdyMCcsXHJcbiAgICAgICAgICAgICAgICBtYXhCaXRyYXRlOiAxMDAwMDAsXHJcbiAgICAgICAgICAgICAgICBzY2FsYWJpbGl0eU1vZGU6ICdTMVQzJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJpZDogJ3IxJyxcclxuICAgICAgICAgICAgICAgIG1heEJpdHJhdGU6IDMwMDAwMCxcclxuICAgICAgICAgICAgICAgIHNjYWxhYmlsaXR5TW9kZTogJ1MxVDMnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmlkOiAncjInLFxyXG4gICAgICAgICAgICAgICAgbWF4Qml0cmF0ZTogOTAwMDAwLFxyXG4gICAgICAgICAgICAgICAgc2NhbGFiaWxpdHlNb2RlOiAnUzFUMycsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9tZWRpYXNvdXAub3JnL2RvY3VtZW50YXRpb24vdjMvbWVkaWFzb3VwLWNsaWVudC9hcGkvI1Byb2R1Y2VyQ29kZWNPcHRpb25zXHJcbiAgICAgICAgICAgIGNvZGVjT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgIHZpZGVvR29vZ2xlU3RhcnRCaXRyYXRlOiAxMDAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgdGhpcy5hdWRpb1BhcmFtcztcclxuICAgICAgICAgIHRoaXMuY29uc3VtaW5nVHJhbnNwb3J0cyA9IFtdO1xyXG5cclxuICAgICAgICAgIHRoaXMudmlkZW9QYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIC8vIG1lZGlhc291cCBwYXJhbXNcclxuICAgICAgICAgICAgZW5jb2RpbmdzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmlkOiAncjAnLFxyXG4gICAgICAgICAgICAgICAgbWF4Qml0cmF0ZTogMTAwMDAwLFxyXG4gICAgICAgICAgICAgICAgc2NhbGFiaWxpdHlNb2RlOiAnUzFUMycsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByaWQ6ICdyMScsXHJcbiAgICAgICAgICAgICAgICBtYXhCaXRyYXRlOiAzMDAwMDAsXHJcbiAgICAgICAgICAgICAgICBzY2FsYWJpbGl0eU1vZGU6ICdTMVQzJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJpZDogJ3IyJyxcclxuICAgICAgICAgICAgICAgIG1heEJpdHJhdGU6IDkwMDAwMCxcclxuICAgICAgICAgICAgICAgIHNjYWxhYmlsaXR5TW9kZTogJ1MxVDMnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbWVkaWFzb3VwLm9yZy9kb2N1bWVudGF0aW9uL3YzL21lZGlhc291cC1jbGllbnQvYXBpLyNQcm9kdWNlckNvZGVjT3B0aW9uc1xyXG4gICAgICAgICAgICBjb2RlY09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICB2aWRlb0dvb2dsZVN0YXJ0Qml0cmF0ZTogMTAwMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnNpZ25hbE5ld0NvbnN1bWVyVHJhbnNwb3J0PXRoaXMuc2lnbmFsTmV3Q29uc3VtZXJUcmFuc3BvcnQuYmluZCh0aGlzKVxyXG4gICAgICAgICAgdGhpcy5jb25uZWN0UmVjdlRyYW5zcG9ydD10aGlzLmNvbm5lY3RSZWN2VHJhbnNwb3J0LmJpbmQodGhpcylcclxuICAgICAgICAgIHRoaXMuc2lnbmFsTmV3Q29uc3VtZXJUcmFuc3BvcnRIb3N0PXRoaXMuc2lnbmFsTmV3Q29uc3VtZXJUcmFuc3BvcnRIb3N0LmJpbmQodGhpcylcclxuXHJcbiAgICAgICAgICAvLyB0aGlzLnNpZ25hbE5ld0NvbnN1bWVyVHJhbnNwb3J0PXRoaXMuc2lnbmFsTmV3Q29uc3VtZXJUcmFuc3BvcnQuYmluZCh0aGlzKVxyXG4gICAgICAgICAgXHJcbiAgICB9XHJcbiAgICBqb2luUm9vbSAoKSB7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLm15c3RyZWFtKVxyXG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCdqb2luUm9vbScsIHsgcm9vbU5hbWU6dGhpcy5yb29tTmFtZSB9LCAoZGF0YSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSb3V0ZXIgUlRQIENhcGFiaWxpdGllcy4uLiAke2RhdGEucnRwQ2FwYWJpbGl0aWVzfWApXHJcbiAgICAgICAgLy8gd2UgYXNzaWduIHRvIGxvY2FsIHZhcmlhYmxlIGFuZCB3aWxsIGJlIHVzZWQgd2hlblxyXG4gICAgICAgIC8vIGxvYWRpbmcgdGhlIGNsaWVudCBEZXZpY2UgKHNlZSBjcmVhdGVEZXZpY2UgYWJvdmUpXHJcbiAgICAgICAgdGhpcy5ydHBDYXBhYmlsaXRpZXMgPSBkYXRhLnJ0cENhcGFiaWxpdGllc1xyXG4gICAgXHJcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIHJ0cENhcGFiaWxpdGllcyBmcm9tIHRoZSBSb3V0ZXIsIGNyZWF0ZSBEZXZpY2VcclxuICAgICAgICB0aGlzLmNyZWF0ZURldmljZSgpXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICBzdHJlYW1TdWNjZXNzKHN0cmVhbSl7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwic3VjY2VzZmZ1bHkgZ2V0IHRoZSBtZWRpYVwiKVxyXG4gICAgICBcclxuICAgICAgaWYgKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIGEgc2lsZW50IGF1ZGlvIHRyYWNrIGlmIG5vbmUgZXhpc3RzXHJcbiAgICAgICAgY29uc3Qgc2lsZW50QXVkaW9UcmFjayA9IGNyZWF0ZVNpbGVudEF1ZGlvVHJhY2soKTtcclxuICAgICAgICBzdHJlYW0uYWRkVHJhY2soc2lsZW50QXVkaW9UcmFjayk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5teXN0cmVhbT1zdHJlYW1cclxuICAgICAgdGhpcy5teXN0cmVhbUNvcHk9c3RyZWFtXHJcbiAgICAgIHRoaXMuYXVkaW9QYXJhbXMgPSB7IHRyYWNrOiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgLi4udGhpcy5hdWRpb1BhcmFtcyB9O1xyXG5cclxuICAgIFxyXG4gICAgICB0aGlzLnZpZGVvUGFyYW1zID0geyB0cmFjazogc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0sIC4uLnRoaXMudmlkZW9QYXJhbXMgfTtcclxuICAgIFxyXG4gICAgICB0aGlzLmpvaW5Sb29tKClcclxuICAgIH1cclxuICAgIFxyXG4gICBcclxuICAgICBnZXRMb2NhbFN0cmVhbSAgKCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc2ZmdWx5IGdldCB0aGUgbWVkaWFcIilcclxuICAgICAgaWYodGhpcy5pc3NjcmVlblNoYXJlZCl7XHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xyXG4gICAgICAgICAgICBhdWRpbzogdHJ1ZSxcclxuICAgICAgICAgICAgdmlkZW86dHJ1ZSxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAudGhlbigoc3RyZWFtKT0+e3RoaXMuc3RyZWFtU3VjY2VzcyhzdHJlYW0pfSlcclxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICB2aWRlbzogdHJ1ZSxcclxuICAgICAgICB9KVxyXG4gICAgICAgIC50aGVuKChzdHJlYW0pPT57dGhpcy5zdHJlYW1TdWNjZXNzKHN0cmVhbSl9KVxyXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvci5tZXNzYWdlKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgXHJcbiAgICAvLyBBIGRldmljZSBpcyBhbiBlbmRwb2ludCBjb25uZWN0aW5nIHRvIGEgUm91dGVyIG9uIHRoZVxyXG4gICAgLy8gc2VydmVyIHNpZGUgdG8gc2VuZC9yZWNpdmUgbWVkaWFcclxuICAgIGFzeW5jIGNyZWF0ZURldmljZSAgKCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZGV2aWNlID0gbmV3IERldmljZSgpXHJcbiAgICBcclxuICAgICAgICAvLyBodHRwczovL21lZGlhc291cC5vcmcvZG9jdW1lbnRhdGlvbi92My9tZWRpYXNvdXAtY2xpZW50L2FwaS8jZGV2aWNlLWxvYWRcclxuICAgICAgICAvLyBMb2FkcyB0aGUgZGV2aWNlIHdpdGggUlRQIGNhcGFiaWxpdGllcyBvZiB0aGUgUm91dGVyIChzZXJ2ZXIgc2lkZSlcclxuICAgICAgICBhd2FpdCB0aGlzLmRldmljZS5sb2FkKHtcclxuICAgICAgICAgIC8vIHNlZSBnZXRSdHBDYXBhYmlsaXRpZXMoKSBiZWxvd1xyXG4gICAgICAgICAgcm91dGVyUnRwQ2FwYWJpbGl0aWVzOiB0aGlzLnJ0cENhcGFiaWxpdGllc1xyXG4gICAgICAgIH0pXHJcbiAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygnRGV2aWNlIFJUUCBDYXBhYmlsaXRpZXMnLCB0aGlzLmRldmljZS5ydHBDYXBhYmlsaXRpZXMpXHJcbiAgICBcclxuICAgICAgICAvLyBvbmNlIHRoZSBkZXZpY2UgbG9hZHMsIGNyZWF0ZSB0cmFuc3BvcnRcclxuICAgICAgICB0aGlzLmNyZWF0ZVNlbmRUcmFuc3BvcnQoKVxyXG4gICAgXHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXHJcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdVbnN1cHBvcnRlZEVycm9yJylcclxuICAgICAgICAgIGNvbnNvbGUud2FybignYnJvd3NlciBub3Qgc3VwcG9ydGVkJylcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIGRldmljZSBjcmVhdGVkXCIsdGhpcy5kZXZpY2UpXHJcbiAgICB9XHJcbiAgICBcclxuICAgICBjcmVhdGVTZW5kVHJhbnNwb3J0KCl7XHJcbiAgICAgIC8vIHNlZSBzZXJ2ZXIncyBzb2NrZXQub24oJ2NyZWF0ZVdlYlJ0Y1RyYW5zcG9ydCcsIHNlbmRlcj8sIC4uLilcclxuICAgICAgLy8gdGhpcyBpcyBhIGNhbGwgZnJvbSBQcm9kdWNlciwgc28gc2VuZGVyID0gdHJ1ZVxyXG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCdjcmVhdGVXZWJSdGNUcmFuc3BvcnQnLCB7IGNvbnN1bWVyOiBmYWxzZSB9LCAoeyBwYXJhbXMgfSkgPT4ge1xyXG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc2VuZHMgYmFjayBwYXJhbXMgbmVlZGVkIFxyXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBTZW5kIFRyYW5zcG9ydCBvbiB0aGUgY2xpZW50IHNpZGVcclxuICAgICAgICBpZiAocGFyYW1zLmVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhwYXJhbXMuZXJyb3IpXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhwYXJhbXMpXHJcbiAgICBcclxuICAgICAgICAvLyBjcmVhdGVzIGEgbmV3IFdlYlJUQyBUcmFuc3BvcnQgdG8gc2VuZCBtZWRpYVxyXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXIncyBwcm9kdWNlciB0cmFuc3BvcnQgcGFyYW1zXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9tZWRpYXNvdXAub3JnL2RvY3VtZW50YXRpb24vdjMvbWVkaWFzb3VwLWNsaWVudC9hcGkvI1RyYW5zcG9ydE9wdGlvbnNcclxuICAgICAgICB0aGlzLnByb2R1Y2VyVHJhbnNwb3J0ID0gdGhpcy5kZXZpY2UuY3JlYXRlU2VuZFRyYW5zcG9ydCh7Li4ucGFyYW1zLCBpY2VTZXJ2ZXJzIDogWyB7XHJcbiAgICd1cmxzJyA6ICdzdHVuOnN0dW4xLmwuZ29vZ2xlLmNvbToxOTMwMidcclxuIH1dfSk7XHJcbiAgICBcclxuICAgICAgICAvLyBodHRwczovL21lZGlhc291cC5vcmcvZG9jdW1lbnRhdGlvbi92My9jb21tdW5pY2F0aW9uLWJldHdlZW4tY2xpZW50LWFuZC1zZXJ2ZXIvI3Byb2R1Y2luZy1tZWRpYVxyXG4gICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgcmFpc2VkIHdoZW4gYSBmaXJzdCBjYWxsIHRvIHRyYW5zcG9ydC5wcm9kdWNlKCkgaXMgbWFkZVxyXG4gICAgICAgIC8vIHNlZSBjb25uZWN0U2VuZFRyYW5zcG9ydCgpIGJlbG93XHJcbiAgICAgICAgdGhpcy5wcm9kdWNlclRyYW5zcG9ydC5vbignY29ubmVjdCcsIGFzeW5jICh7IGR0bHNQYXJhbWV0ZXJzIH0sIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBTaWduYWwgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzIHRvIHRoZSBzZXJ2ZXIgc2lkZSB0cmFuc3BvcnRcclxuICAgICAgICAgICAgLy8gc2VlIHNlcnZlcidzIHNvY2tldC5vbigndHJhbnNwb3J0LWNvbm5lY3QnLCAuLi4pXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc29ja2V0LmVtaXQoJ3RyYW5zcG9ydC1jb25uZWN0Jywge1xyXG4gICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIFRlbGwgdGhlIHRyYW5zcG9ydCB0aGF0IHBhcmFtZXRlcnMgd2VyZSB0cmFuc21pdHRlZC5cclxuICAgICAgICAgICAgY2FsbGJhY2soKVxyXG4gICAgXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBlcnJiYWNrKGVycm9yKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICBcclxuICAgICAgICB0aGlzLnByb2R1Y2VyVHJhbnNwb3J0Lm9uKCdwcm9kdWNlJywgYXN5bmMgKHBhcmFtZXRlcnMsIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhwYXJhbWV0ZXJzKVxyXG4gICAgXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyB0ZWxsIHRoZSBzZXJ2ZXIgdG8gY3JlYXRlIGEgUHJvZHVjZXJcclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgYW5kIHByb2R1Y2VcclxuICAgICAgICAgICAgLy8gYW5kIGV4cGVjdCBiYWNrIGEgc2VydmVyIHNpZGUgcHJvZHVjZXIgaWRcclxuICAgICAgICAgICAgLy8gc2VlIHNlcnZlcidzIHNvY2tldC5vbigndHJhbnNwb3J0LXByb2R1Y2UnLCAuLi4pXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc29ja2V0LmVtaXQoJ3RyYW5zcG9ydC1wcm9kdWNlJywge1xyXG4gICAgICAgICAgICAgIGtpbmQ6IHBhcmFtZXRlcnMua2luZCxcclxuICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLnJ0cFBhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgICAgYXBwRGF0YTogcGFyYW1ldGVycy5hcHBEYXRhLFxyXG4gICAgICAgICAgICAgIGFkbWluOnRoaXMuaXNBZG1pbixcclxuICAgICAgICAgICAgICB2aWV3ZXI6ZmFsc2VcclxuICAgICAgICAgICAgfSwgKHsgaWQsIHByb2R1Y2Vyc0V4aXN0IH0pID0+IHtcclxuICAgICAgICAgICAgICAvLyBUZWxsIHRoZSB0cmFuc3BvcnQgdGhhdCBwYXJhbWV0ZXJzIHdlcmUgdHJhbnNtaXR0ZWQgYW5kIHByb3ZpZGUgaXQgd2l0aCB0aGVcclxuICAgICAgICAgICAgICAvLyBzZXJ2ZXIgc2lkZSBwcm9kdWNlcidzIGlkLlxyXG4gICAgICAgICAgICAgIGNhbGxiYWNrKHsgaWQgfSlcclxuICAgIFxyXG4gICAgICAgICAgICAgIC8vIGlmIHByb2R1Y2VycyBleGlzdCwgdGhlbiBqb2luIHJvb21cclxuICAgICAgICAgICAgICBpZiAocHJvZHVjZXJzRXhpc3QpIHRoaXMuZ2V0UHJvZHVjZXJzKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGVycmJhY2soZXJyb3IpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIFxyXG4gICAgICAgIHRoaXMuY29ubmVjdFNlbmRUcmFuc3BvcnQoKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZVNjcmVlblNoYXJlT2ZmKCl7XHJcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcclxuICAgICAgICBhdWRpbzogdHJ1ZSxcclxuICAgICAgICB2aWRlbzoge1xyXG4gICAgICAgICAgd2lkdGg6IHtcclxuICAgICAgICAgICAgbWluOiA2NDAsXHJcbiAgICAgICAgICAgIG1heDogMTkyMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBoZWlnaHQ6IHtcclxuICAgICAgICAgICAgbWluOiA0MDAsXHJcbiAgICAgICAgICAgIG1heDogMTA4MCxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKChzdHJlYW0pPT57XHJcbiAgICAgICAgdGhpcy52aWRlb1BhcmFtcyA9IHsgdHJhY2s6IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdLCAuLi50aGlzLnZpZGVvUGFyYW1zIH07IFxyXG4gICAgICAgIGNvbnN0IHZpZGVvVHJhY2tzID0gdGhpcy5teXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBlYWNoIHZpZGVvIHRyYWNrXHJcbiAgICAgICAgdmlkZW9UcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgICAgICB0aGlzLm15c3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcclxuICAgICAgICAgIHRyYWNrLnN0b3AoKTsgLy8gU3RvcCB0aGUgcmVtb3ZlZCB0cmFjayB0byByZWxlYXNlIHJlc291cmNlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubXlzdHJlYW0uYWRkVHJhY2soc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0pO1xyXG4gICAgICAgIHRoaXMudmlkZW9Qcm9kdWNlci5yZXBsYWNlVHJhY2soeyB0cmFjazogc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0gfSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IubWVzc2FnZSlcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIGdldGxvY2FsRGlzcGxheVNjcmVlbigpe1xyXG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSh7IHZpZGVvOiB0cnVlIH0pXHJcbiAgICAgIC50aGVuKChzdHJlYW0pPT57XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuVHJhY2sgPSBzdHJlYW0uZ2V0VHJhY2tzKClbMF07XHJcbiAgICAgICAgdGhpcy52aWRlb1Byb2R1Y2VyLnJlcGxhY2VUcmFjayh7IHRyYWNrOiBzY3JlZW5UcmFjayB9KTtcclxuICAgICAgICAgICAgc2NyZWVuVHJhY2sub25lbmRlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHRoaXMudmlkZW9Qcm9kdWNlci5yZXBsYWNlVHJhY2sodXNlclN0cmVhbS5jdXJyZW50LmdldFRyYWNrcygpWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZpZGVvVHJhY2tzID0gdGhpcy5teXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZWFjaCB2aWRlbyB0cmFja1xyXG4gICAgICAgICAgICB2aWRlb1RyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLm15c3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcclxuICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7IC8vIFN0b3AgdGhlIHJlbW92ZWQgdHJhY2sgdG8gcmVsZWFzZSByZXNvdXJjZXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubXlzdHJlYW0uYWRkVHJhY2soc2NyZWVuVHJhY2spO1xyXG5cclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvci5tZXNzYWdlKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNvbm5lY3RTZW5kVHJhbnNwb3J0ICgpe1xyXG4gICAgICAvLyB3ZSBub3cgY2FsbCBwcm9kdWNlKCkgdG8gaW5zdHJ1Y3QgdGhlIHByb2R1Y2VyIHRyYW5zcG9ydFxyXG4gICAgICAvLyB0byBzZW5kIG1lZGlhIHRvIHRoZSBSb3V0ZXJcclxuICAgICAgLy8gaHR0cHM6Ly9tZWRpYXNvdXAub3JnL2RvY3VtZW50YXRpb24vdjMvbWVkaWFzb3VwLWNsaWVudC9hcGkvI3RyYW5zcG9ydC1wcm9kdWNlXHJcbiAgICAgIC8vIHRoaXMgYWN0aW9uIHdpbGwgdHJpZ2dlciB0aGUgJ2Nvbm5lY3QnIGFuZCAncHJvZHVjZScgZXZlbnRzIGFib3ZlXHJcbiAgICAgIGlmKHRoaXMubXlzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSE9W10pXHJcbiAgICAgICAgdGhpcy5hdWRpb1Byb2R1Y2VyID0gYXdhaXQgdGhpcy5wcm9kdWNlclRyYW5zcG9ydC5wcm9kdWNlKHRoaXMuYXVkaW9QYXJhbXMpO1xyXG4gICAgICB0aGlzLnZpZGVvUHJvZHVjZXIgPSBhd2FpdCB0aGlzLnByb2R1Y2VyVHJhbnNwb3J0LnByb2R1Y2UodGhpcy52aWRlb1BhcmFtcyk7XHJcbiAgICAgIHRoaXMuYXVkaW9Qcm9kdWNlci5vbigndHJhY2tlbmRlZCcsICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnYXVkaW8gdHJhY2sgZW5kZWQnKVxyXG4gICAgICAgIHRoaXMuYXVkaW9EaXNjb25uZWN0PXRydWVcclxuICAgICAgICAvLyBjbG9zZSBhdWRpbyB0cmFja1xyXG4gICAgICB9KVxyXG4gICAgXHJcbiAgICAgIHRoaXMuYXVkaW9Qcm9kdWNlci5vbigndHJhbnNwb3J0Y2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2F1ZGlvIHRyYW5zcG9ydCBlbmRlZCcpXHJcbiAgICAgICAgdGhpcy5hdWRpb0Rpc2Nvbm5lY3Q9dHJ1ZVxyXG4gICAgXHJcbiAgICAgICAgLy8gY2xvc2UgYXVkaW8gdHJhY2tcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIHRoaXMudmlkZW9Qcm9kdWNlci5vbigndHJhY2tlbmRlZCcsICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygndmlkZW8gdHJhY2sgZW5kZWQnKVxyXG4gICAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLnZpZGVvRGlzY29ubmVjdD10cnVlXHJcbiAgICAgICAgLy8gY2xvc2UgdmlkZW8gdHJhY2tcclxuICAgICAgfSlcclxuICAgIFxyXG4gICAgICB0aGlzLnZpZGVvUHJvZHVjZXIub24oJ3RyYW5zcG9ydGNsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCd2aWRlbyB0cmFuc3BvcnQgZW5kZWQnKVxyXG4gICAgICAgIHRoaXMudmlkZW9EaXNjb25uZWN0PXRydWVcclxuICAgIFxyXG4gICAgICAgIC8vIGNsb3NlIHZpZGVvIHRyYWNrXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBcclxuICAgYXN5bmMgc2lnbmFsTmV3Q29uc3VtZXJUcmFuc3BvcnQgKHJlbW90ZVByb2R1Y2VySWQsdmlld2VyKXtcclxuICAgICAgLy9jaGVjayBpZiB3ZSBhcmUgYWxyZWFkeSBjb25zdW1pbmcgdGhlIHJlbW90ZVByb2R1Y2VySWRcclxuICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIHZpZXdlciBpbiBzdGFydCBcIix2aWV3ZXIpXHJcbiAgICAgIGlmICh0aGlzLmNvbnN1bWluZ1RyYW5zcG9ydHMuaW5jbHVkZXMocmVtb3RlUHJvZHVjZXJJZCkpIHJldHVybjtcclxuICAgICAgdGhpcy5jb25zdW1pbmdUcmFuc3BvcnRzLnB1c2gocmVtb3RlUHJvZHVjZXJJZCk7XHJcbiAgICBcclxuICAgICAgYXdhaXQgdGhpcy5zb2NrZXQuZW1pdCgnY3JlYXRlV2ViUnRjVHJhbnNwb3J0JywgeyBjb25zdW1lcjogdHJ1ZSB9LCAoeyBwYXJhbXMgfSkgPT4ge1xyXG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc2VuZHMgYmFjayBwYXJhbXMgbmVlZGVkIFxyXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBTZW5kIFRyYW5zcG9ydCBvbiB0aGUgY2xpZW50IHNpZGVcclxuICAgICAgICBpZiAocGFyYW1zLmVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhwYXJhbXMuZXJyb3IpXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coYFBBUkFNUy4uLiAke3BhcmFtc31gKVxyXG4gICAgXHJcbiAgICAgICAgbGV0IGNvbnN1bWVyVHJhbnNwb3J0XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2hlY2tpbmcgXCIsdGhpcy5teXN0cmVhbSlcclxuICAgICAgICAgIGNvbnN1bWVyVHJhbnNwb3J0ID0gdGhpcy5kZXZpY2UuY3JlYXRlUmVjdlRyYW5zcG9ydChwYXJhbXMpXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIGV4Y2VwdGlvbnM6IFxyXG4gICAgICAgICAgLy8ge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkXHJcbiAgICAgICAgICAvLyB7VHlwZUVycm9yfSBpZiB3cm9uZyBhcmd1bWVudHMuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGNvbnN1bWVyVHJhbnNwb3J0Lm9uKCdjb25uZWN0JywgYXN5bmMgKHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFNpZ25hbCBsb2NhbCBEVExTIHBhcmFtZXRlcnMgdG8gdGhlIHNlcnZlciBzaWRlIHRyYW5zcG9ydFxyXG4gICAgICAgICAgICAvLyBzZWUgc2VydmVyJ3Mgc29ja2V0Lm9uKCd0cmFuc3BvcnQtcmVjdi1jb25uZWN0JywgLi4uKVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNvY2tldC5lbWl0KCd0cmFuc3BvcnQtcmVjdi1jb25uZWN0Jywge1xyXG4gICAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgIHNlcnZlckNvbnN1bWVyVHJhbnNwb3J0SWQ6IHBhcmFtcy5pZCxcclxuICAgICAgICAgICAgfSlcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBUZWxsIHRoZSB0cmFuc3BvcnQgdGhhdCBwYXJhbWV0ZXJzIHdlcmUgdHJhbnNtaXR0ZWQuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKClcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIFRlbGwgdGhlIHRyYW5zcG9ydCB0aGF0IHNvbWV0aGluZyB3YXMgd3JvbmdcclxuICAgICAgICAgICAgZXJyYmFjayhlcnJvcilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgXHJcbiAgICAgICAgdGhpcy5jb25uZWN0UmVjdlRyYW5zcG9ydChjb25zdW1lclRyYW5zcG9ydCwgcmVtb3RlUHJvZHVjZXJJZCwgcGFyYW1zLmlkLHZpZXdlcilcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBhc3luYyBzaWduYWxOZXdDb25zdW1lclRyYW5zcG9ydEhvc3QgKGhvc3RkYXRhLHNvY2tldElkKXtcclxuICAgICAgLy9jaGVjayBpZiB3ZSBhcmUgYWxyZWFkeSBjb25zdW1pbmcgdGhlIHJlbW90ZVByb2R1Y2VySWRcclxuICAgICBcclxuICAgICAgaWYgKHRoaXMuY29uc3VtaW5nVHJhbnNwb3J0cy5pbmNsdWRlcyhob3N0ZGF0YVsncHJvZHVjZXJJZCddKSkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmNvbnN1bWluZ1RyYW5zcG9ydHMucHVzaChob3N0ZGF0YVsncHJvZHVjZXJJZCddKTtcclxuICAgIFxyXG4gICAgICBhd2FpdCB0aGlzLnNvY2tldC5lbWl0KCdjcmVhdGVXZWJSdGNUcmFuc3BvcnQnLCB7IGNvbnN1bWVyOiB0cnVlIH0sICh7IHBhcmFtcyB9KSA9PiB7XHJcbiAgICAgICAgLy8gVGhlIHNlcnZlciBzZW5kcyBiYWNrIHBhcmFtcyBuZWVkZWQgXHJcbiAgICAgICAgLy8gdG8gY3JlYXRlIFNlbmQgVHJhbnNwb3J0IG9uIHRoZSBjbGllbnQgc2lkZVxyXG4gICAgICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKHBhcmFtcy5lcnJvcilcclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhgUEFSQU1TLi4uICR7cGFyYW1zfWApXHJcbiAgICBcclxuICAgICAgICBsZXQgY29uc3VtZXJUcmFuc3BvcnRcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJjaGVja2luZyBcIix0aGlzLm15c3RyZWFtKVxyXG4gICAgICAgICAgY29uc3VtZXJUcmFuc3BvcnQgPSB0aGlzLmRldmljZS5jcmVhdGVSZWN2VHJhbnNwb3J0KHBhcmFtcylcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gZXhjZXB0aW9uczogXHJcbiAgICAgICAgICAvLyB7SW52YWxpZFN0YXRlRXJyb3J9IGlmIG5vdCBsb2FkZWRcclxuICAgICAgICAgIC8vIHtUeXBlRXJyb3J9IGlmIHdyb25nIGFyZ3VtZW50cy5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgY29uc3VtZXJUcmFuc3BvcnQub24oJ2Nvbm5lY3QnLCBhc3luYyAoeyBkdGxzUGFyYW1ldGVycyB9LCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gU2lnbmFsIGxvY2FsIERUTFMgcGFyYW1ldGVycyB0byB0aGUgc2VydmVyIHNpZGUgdHJhbnNwb3J0XHJcbiAgICAgICAgICAgIC8vIHNlZSBzZXJ2ZXIncyBzb2NrZXQub24oJ3RyYW5zcG9ydC1yZWN2LWNvbm5lY3QnLCAuLi4pXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc29ja2V0LmVtaXQoJ3RyYW5zcG9ydC1yZWN2LWNvbm5lY3QnLCB7XHJcbiAgICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgICAgc2VydmVyQ29uc3VtZXJUcmFuc3BvcnRJZDogcGFyYW1zLmlkLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIFRlbGwgdGhlIHRyYW5zcG9ydCB0aGF0IHBhcmFtZXRlcnMgd2VyZSB0cmFuc21pdHRlZC5cclxuICAgICAgICAgICAgY2FsbGJhY2soKVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gVGVsbCB0aGUgdHJhbnNwb3J0IHRoYXQgc29tZXRoaW5nIHdhcyB3cm9uZ1xyXG4gICAgICAgICAgICBlcnJiYWNrKGVycm9yKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICBcclxuICAgICAgICB0aGlzLmNvbm5lY3RSZWN2VHJhbnNwb3J0SG9zdChjb25zdW1lclRyYW5zcG9ydCwgaG9zdGRhdGEsc29ja2V0SWQsIHBhcmFtcy5pZClcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICAgIC8vIHNlcnZlciBpbmZvcm1zIHRoZSBjbGllbnQgb2YgYSBuZXcgcHJvZHVjZXIganVzdCBqb2luZWRcclxuICAgIFxyXG4gICAgZ2V0UHJvZHVjZXJzKCkge1xyXG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCdnZXRQcm9kdWNlcnMnLCBwcm9kdWNlcklkcyA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2cocHJvZHVjZXJJZHMpXHJcbiAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIHByb2R1Y2VyIGNyZWF0ZSBhIGNvbnN1bWVyXHJcbiAgICAgICAgLy8gcHJvZHVjZXJJZHMuZm9yRWFjaChpZCA9PiBzaWduYWxOZXdDb25zdW1lclRyYW5zcG9ydChpZCkpXHJcbiAgICAgICAgcHJvZHVjZXJJZHMuZm9yRWFjaCh0aGlzLnNpZ25hbE5ld0NvbnN1bWVyVHJhbnNwb3J0SG9zdClcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIGFzeW5jIGNvbm5lY3RSZWN2VHJhbnNwb3J0SG9zdCAoY29uc3VtZXJUcmFuc3BvcnQsIGhvc3RkYXRhLHNvY2tldElkLCBzZXJ2ZXJDb25zdW1lclRyYW5zcG9ydElkKXtcclxuICAgICAgLy8gZm9yIGNvbnN1bWVyLCB3ZSBuZWVkIHRvIHRlbGwgdGhlIHNlcnZlciBmaXJzdFxyXG4gICAgICAvLyB0byBjcmVhdGUgYSBjb25zdW1lciBiYXNlZCBvbiB0aGUgcnRwQ2FwYWJpbGl0aWVzIGFuZCBjb25zdW1lXHJcbiAgICAgIC8vIGlmIHRoZSByb3V0ZXIgY2FuIGNvbnN1bWUsIGl0IHdpbGwgc2VuZCBiYWNrIGEgc2V0IG9mIHBhcmFtcyBhcyBiZWxvd1xyXG4gICAgICBhd2FpdCB0aGlzLnNvY2tldC5lbWl0KCdjb25zdW1lJywge1xyXG4gICAgICAgIHJ0cENhcGFiaWxpdGllczogdGhpcy5kZXZpY2UucnRwQ2FwYWJpbGl0aWVzLFxyXG4gICAgICAgIHJlbW90ZVByb2R1Y2VySWQ6aG9zdGRhdGFbJ3Byb2R1Y2VySWQnXSxcclxuICAgICAgICBzZXJ2ZXJDb25zdW1lclRyYW5zcG9ydElkLFxyXG4gICAgICB9LCBhc3luYyAoeyBwYXJhbXMgfSkgPT4ge1xyXG4gICAgICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW5ub3QgQ29uc3VtZScpXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ29uc3VtZXIgUGFyYW1zICR7cGFyYW1zfWApXHJcbiAgICAgICAgLy8gdGhlbiBjb25zdW1lIHdpdGggdGhlIGxvY2FsIGNvbnN1bWVyIHRyYW5zcG9ydFxyXG4gICAgICAgIC8vIHdoaWNoIGNyZWF0ZXMgYSBjb25zdW1lclxyXG4gICAgICAgIGNvbnN0IGNvbnN1bWVyID0gYXdhaXQgY29uc3VtZXJUcmFuc3BvcnQuY29uc3VtZSh7XHJcbiAgICAgICAgICBpZDogcGFyYW1zLmlkLFxyXG4gICAgICAgICAgcHJvZHVjZXJJZDogcGFyYW1zLnByb2R1Y2VySWQsXHJcbiAgICAgICAgICBraW5kOiBwYXJhbXMua2luZCxcclxuICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHBhcmFtcy5ydHBQYXJhbWV0ZXJzXHJcbiAgICAgICAgfSlcclxuICAgIFxyXG4gICAgICAgIHRoaXMuY29uc3VtZXJUcmFuc3BvcnRzID0gW1xyXG4gICAgICAgICAgLi4udGhpcy5jb25zdW1lclRyYW5zcG9ydHMsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN1bWVyVHJhbnNwb3J0LFxyXG4gICAgICAgICAgICBzZXJ2ZXJDb25zdW1lclRyYW5zcG9ydElkOiBwYXJhbXMuaWQsXHJcbiAgICAgICAgICAgIHByb2R1Y2VySWQ6IGhvc3RkYXRhWydwcm9kdWNlcklkJ10sXHJcbiAgICAgICAgICAgIGNvbnN1bWVyLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdXHJcbiAgICBcclxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgZGl2IGVsZW1lbnQgZm9yIHRoZSBuZXcgY29uc3VtZXIgbWVkaWFcclxuICAgICAgICBcclxuICAgICAgICAvLyBkZXN0cnVjdHVyZSBhbmQgcmV0cmlldmUgdGhlIHZpZGVvIHRyYWNrIGZyb20gdGhlIHByb2R1Y2VyXHJcbiAgICAgICAgY29uc3QgeyB0cmFjayB9ID0gY29uc3VtZXI7XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhY2ssJ3RyYWNrIHJlY2VpdmUnKVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcInRyYWNrIFwiICx0cmFjayAsXCIgcHJvZHVjZXIgaWQgXCIsaG9zdGRhdGFbJ3Byb2R1Y2VySWQnXSlcclxuICAgICAgICBsZXQgdHJhY2tyZXE9bmV3IE1lZGlhU3RyZWFtKFt0cmFja10pXHJcbiAgICAgICBcclxuICAgICAgICBpZiAoIXRoaXMubWFpblRyYWNrc1tzb2NrZXRJZF0pe1xyXG4gICAgICAgICAgdGhpcy5tYWluVHJhY2tzW3NvY2tldElkXT1bXVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1haW5UcmFja3Nbc29ja2V0SWRdLnB1c2goe1xyXG4gICAgICAgICAgcHJvZHVjZXJJZDpob3N0ZGF0YVsncHJvZHVjZXJJZCddLFxyXG4gICAgICAgICAgbWVkaWE6dHJhY2tyZXEsXHJcbiAgICAgICAgICBwcm9kdWNlcktpbmQ6aG9zdGRhdGFbJ3Byb2R1Y2VyS2luZCddIFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlbW90ZVByb2R1Y2VySWQpLnNyY09iamVjdCA9IG5ldyBNZWRpYVN0cmVhbShbdHJhY2tdKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyB0cmFja1wiLHRoaXMubWFpblRyYWNrcylcclxuICAgICAgICAvLyB0aGUgc2VydmVyIGNvbnN1bWVyIHN0YXJ0ZWQgd2l0aCBtZWRpYSBwYXVzZWRcclxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGluZm9ybSB0aGUgc2VydmVyIHRvIHJlc3VtZVxyXG4gICAgICAgIHRoaXMuc29ja2V0LmVtaXQoJ2NvbnN1bWVyLXJlc3VtZScsIHsgc2VydmVyQ29uc3VtZXJJZDogcGFyYW1zLnNlcnZlckNvbnN1bWVySWQgfSlcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBhc3luYyBjb25uZWN0UmVjdlRyYW5zcG9ydCAoY29uc3VtZXJUcmFuc3BvcnQsIHJlbW90ZVByb2R1Y2VySWQsIHNlcnZlckNvbnN1bWVyVHJhbnNwb3J0SWQsdmlld2VyKXtcclxuICAgICAgLy8gZm9yIGNvbnN1bWVyLCB3ZSBuZWVkIHRvIHRlbGwgdGhlIHNlcnZlciBmaXJzdFxyXG4gICAgICAvLyB0byBjcmVhdGUgYSBjb25zdW1lciBiYXNlZCBvbiB0aGUgcnRwQ2FwYWJpbGl0aWVzIGFuZCBjb25zdW1lXHJcbiAgICAgIC8vIGlmIHRoZSByb3V0ZXIgY2FuIGNvbnN1bWUsIGl0IHdpbGwgc2VuZCBiYWNrIGEgc2V0IG9mIHBhcmFtcyBhcyBiZWxvd1xyXG4gICAgICBhd2FpdCB0aGlzLnNvY2tldC5lbWl0KCdjb25zdW1lJywge1xyXG4gICAgICAgIHJ0cENhcGFiaWxpdGllczogdGhpcy5kZXZpY2UucnRwQ2FwYWJpbGl0aWVzLFxyXG4gICAgICAgIHJlbW90ZVByb2R1Y2VySWQsXHJcbiAgICAgICAgc2VydmVyQ29uc3VtZXJUcmFuc3BvcnRJZCxcclxuICAgICAgfSwgYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcclxuICAgICAgICBpZiAocGFyYW1zLmVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2Fubm90IENvbnN1bWUnKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYENvbnN1bWVyIFBhcmFtcyAke3BhcmFtc31gKVxyXG4gICAgICAgIC8vIHRoZW4gY29uc3VtZSB3aXRoIHRoZSBsb2NhbCBjb25zdW1lciB0cmFuc3BvcnRcclxuICAgICAgICAvLyB3aGljaCBjcmVhdGVzIGEgY29uc3VtZXJcclxuICAgICAgICBjb25zdCBjb25zdW1lciA9IGF3YWl0IGNvbnN1bWVyVHJhbnNwb3J0LmNvbnN1bWUoe1xyXG4gICAgICAgICAgaWQ6IHBhcmFtcy5pZCxcclxuICAgICAgICAgIHByb2R1Y2VySWQ6IHBhcmFtcy5wcm9kdWNlcklkLFxyXG4gICAgICAgICAga2luZDogcGFyYW1zLmtpbmQsXHJcbiAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBwYXJhbXMucnRwUGFyYW1ldGVyc1xyXG4gICAgICAgIH0pXHJcbiAgICBcclxuICAgICAgICB0aGlzLmNvbnN1bWVyVHJhbnNwb3J0cyA9IFtcclxuICAgICAgICAgIC4uLnRoaXMuY29uc3VtZXJUcmFuc3BvcnRzLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdW1lclRyYW5zcG9ydCxcclxuICAgICAgICAgICAgc2VydmVyQ29uc3VtZXJUcmFuc3BvcnRJZDogcGFyYW1zLmlkLFxyXG4gICAgICAgICAgICBwcm9kdWNlcklkOiByZW1vdGVQcm9kdWNlcklkLFxyXG4gICAgICAgICAgICBjb25zdW1lcixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXVxyXG4gICAgXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGRpdiBlbGVtZW50IGZvciB0aGUgbmV3IGNvbnN1bWVyIG1lZGlhXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZGVzdHJ1Y3R1cmUgYW5kIHJldHJpZXZlIHRoZSB2aWRlbyB0cmFjayBmcm9tIHRoZSBwcm9kdWNlclxyXG4gICAgICAgIGNvbnN0IHsgdHJhY2sgfSA9IGNvbnN1bWVyXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwidHJhY2sgXCIgLHRyYWNrICxcIiBwcm9kdWNlciBpZCBcIixyZW1vdGVQcm9kdWNlcklkKVxyXG4gICAgICAgIGxldCB0cmFja3JlcT1uZXcgTWVkaWFTdHJlYW0oW3RyYWNrXSlcclxuICAgICAgIFxyXG4gICAgICAgXHJcbiAgICAgICAgaWYodmlld2VyKXtcclxuICAgICAgICAgIHRoaXMuY2FsbGVycy5wdXNoKHRyYWNrcmVxKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgdGhpcy5tYWluVHJhY2tzLnB1c2godHJhY2tyZXEpXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVtb3RlUHJvZHVjZXJJZCkuc3JjT2JqZWN0ID0gbmV3IE1lZGlhU3RyZWFtKFt0cmFja10pXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIHRyYWNrXCIsdHJhY2spXHJcbiAgICAgICAgLy8gdGhlIHNlcnZlciBjb25zdW1lciBzdGFydGVkIHdpdGggbWVkaWEgcGF1c2VkXHJcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBpbmZvcm0gdGhlIHNlcnZlciB0byByZXN1bWVcclxuICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdjb25zdW1lci1yZXN1bWUnLCB7IHNlcnZlckNvbnN1bWVySWQ6IHBhcmFtcy5zZXJ2ZXJDb25zdW1lcklkIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBcclxuXHJcbn1cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlIiwiRGV2aWNlIiwic2V0UmVxdWVzdE1ldGEiLCJjcmVhdGVTaWxlbnRBdWRpb1RyYWNrIiwiYXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0Iiwib3NjaWxsYXRvciIsImNyZWF0ZU9zY2lsbGF0b3IiLCJkZXN0aW5hdGlvbiIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJmcmVxdWVuY3kiLCJ2YWx1ZSIsImNvbm5lY3QiLCJzdGFydCIsInN0cmVhbSIsImdldEF1ZGlvVHJhY2tzIiwid2VicnRjTWVkaWFTb3VwX2NsaWVudCIsImpvaW5Sb29tIiwiY29uc29sZSIsImxvZyIsIm15c3RyZWFtIiwic29ja2V0IiwiZW1pdCIsInJvb21OYW1lIiwiZGF0YSIsInJ0cENhcGFiaWxpdGllcyIsImNyZWF0ZURldmljZSIsInN0cmVhbVN1Y2Nlc3MiLCJsZW5ndGgiLCJzaWxlbnRBdWRpb1RyYWNrIiwiYWRkVHJhY2siLCJteXN0cmVhbUNvcHkiLCJhdWRpb1BhcmFtcyIsInRyYWNrIiwidmlkZW9QYXJhbXMiLCJnZXRWaWRlb1RyYWNrcyIsImdldExvY2FsU3RyZWFtIiwiaXNzY3JlZW5TaGFyZWQiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXREaXNwbGF5TWVkaWEiLCJhdWRpbyIsInZpZGVvIiwidGhlbiIsImNhdGNoIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0VXNlck1lZGlhIiwiZGV2aWNlIiwibG9hZCIsInJvdXRlclJ0cENhcGFiaWxpdGllcyIsImNyZWF0ZVNlbmRUcmFuc3BvcnQiLCJuYW1lIiwid2FybiIsImNvbnN1bWVyIiwicGFyYW1zIiwicHJvZHVjZXJUcmFuc3BvcnQiLCJpY2VTZXJ2ZXJzIiwib24iLCJjYWxsYmFjayIsImVycmJhY2siLCJkdGxzUGFyYW1ldGVycyIsInBhcmFtZXRlcnMiLCJraW5kIiwicnRwUGFyYW1ldGVycyIsImFwcERhdGEiLCJhZG1pbiIsImlzQWRtaW4iLCJ2aWV3ZXIiLCJpZCIsInByb2R1Y2Vyc0V4aXN0IiwiZ2V0UHJvZHVjZXJzIiwiY29ubmVjdFNlbmRUcmFuc3BvcnQiLCJoYW5kbGVTY3JlZW5TaGFyZU9mZiIsIndpZHRoIiwibWluIiwibWF4IiwiaGVpZ2h0IiwidmlkZW9UcmFja3MiLCJmb3JFYWNoIiwicmVtb3ZlVHJhY2siLCJzdG9wIiwidmlkZW9Qcm9kdWNlciIsInJlcGxhY2VUcmFjayIsImdldGxvY2FsRGlzcGxheVNjcmVlbiIsInNjcmVlblRyYWNrIiwiZ2V0VHJhY2tzIiwib25lbmRlZCIsInVzZXJTdHJlYW0iLCJjdXJyZW50IiwiYXVkaW9Qcm9kdWNlciIsInByb2R1Y2UiLCJhdWRpb0Rpc2Nvbm5lY3QiLCJkaXNjb25uZWN0IiwidmlkZW9EaXNjb25uZWN0Iiwic2lnbmFsTmV3Q29uc3VtZXJUcmFuc3BvcnQiLCJyZW1vdGVQcm9kdWNlcklkIiwiY29uc3VtaW5nVHJhbnNwb3J0cyIsImluY2x1ZGVzIiwicHVzaCIsImNvbnN1bWVyVHJhbnNwb3J0IiwiY3JlYXRlUmVjdlRyYW5zcG9ydCIsInNlcnZlckNvbnN1bWVyVHJhbnNwb3J0SWQiLCJjb25uZWN0UmVjdlRyYW5zcG9ydCIsInNpZ25hbE5ld0NvbnN1bWVyVHJhbnNwb3J0SG9zdCIsImhvc3RkYXRhIiwic29ja2V0SWQiLCJjb25uZWN0UmVjdlRyYW5zcG9ydEhvc3QiLCJwcm9kdWNlcklkcyIsImNvbnN1bWUiLCJwcm9kdWNlcklkIiwiY29uc3VtZXJUcmFuc3BvcnRzIiwidHJhY2tyZXEiLCJNZWRpYVN0cmVhbSIsIm1haW5UcmFja3MiLCJtZWRpYSIsInByb2R1Y2VyS2luZCIsInNlcnZlckNvbnN1bWVySWQiLCJjYWxsZXJzIiwiY29uc3RydWN0b3IiLCJpc1Byb2R1Y2VyIiwiZW5jb2RpbmdzIiwicmlkIiwibWF4Qml0cmF0ZSIsInNjYWxhYmlsaXR5TW9kZSIsImNvZGVjT3B0aW9ucyIsInZpZGVvR29vZ2xlU3RhcnRCaXRyYXRlIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/mediasoup/webrtc_mediasoup_host.js\n"));

/***/ })

});